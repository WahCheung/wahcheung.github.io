<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/sanji.jpg?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-sanji.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-sanji.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="每一个认真的技术人心底都有一个技术英雄梦">
<meta property="og:type" content="website">
<meta property="og:title" content="工程师学徒">
<meta property="og:url" content="https://cheung.site/index.html">
<meta property="og:site_name" content="工程师学徒">
<meta property="og:description" content="每一个认真的技术人心底都有一个技术英雄梦">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="工程师学徒">
<meta name="twitter:description" content="每一个认真的技术人心底都有一个技术英雄梦">



  <link rel="alternate" href="/atom.xml" title="工程师学徒" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://cheung.site/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>工程师学徒</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">工程师学徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2020/04/07/apollo-routing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/07/apollo-routing/" class="post-title-link" itemprop="url">Apollo Routing路径导航</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-07 17:55:41" itemprop="dateCreated datePublished" datetime="2020-04-07T17:55:41+08:00">2020-04-07</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Apollo自动驾驶/" itemprop="url" rel="index"><span itemprop="name">Apollo自动驾驶</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Routing模块概述"><a href="#Routing模块概述" class="headerlink" title="Routing模块概述"></a>Routing模块概述</h2><p>Routing模块给自动驾驶系统提供全局的路由导航功能，类似于百度地图/高德地图的导航。在收到路由请求之后，为了完成导航功能，Routing模块使用了专用的路由地图<code>routing_map</code>。最终输出的是自动驾驶车辆在从出发点到目的地的过程中经过的所有路段。</p>
<h2 id="路由请求的形式"><a href="#路由请求的形式" class="headerlink" title="路由请求的形式"></a>路由请求的形式</h2><p>Apollo路由请求实现的功能与百度地图/高德地图的导航类似，都是完成从起点到目的地的行驶路段规划，但Apollo Routing模块支持添加多个必经点(Waypoint/航点)，最终输出的路由结果会依次经过这些航点。举个例子，你想从深圳(起点)开车到广州(终点)，你只需要两个航点<code>深圳-&gt;广州</code>；如果你想先途径东莞再到广州，你需要输入的航点的顺序是<code>深圳-&gt;东莞-&gt;广州</code>。Apollo中的航点指定需要经过某条Lane的指定位置。<br>Apollo中路由请求的具体形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">message LaneWaypoint &#123;</span><br><span class="line">  // Note: waypoint所在的Lane的Id</span><br><span class="line">  optional string id = 1;</span><br><span class="line">  // Note: waypoint相对于Lane起点的距离</span><br><span class="line">  optional double s = 2;</span><br><span class="line">  // Note: waypoint的坐标</span><br><span class="line">  optional apollo.common.PointENU pose = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LaneSegment &#123;</span><br><span class="line">  // Note: 所在Lane的Id</span><br><span class="line">  optional string id = 1;</span><br><span class="line">  // Note: Segment起始位置的s(相对于所在Lane的起点)</span><br><span class="line">  optional double start_s = 2;</span><br><span class="line">  // Note: Segment结束位置的s(相对于所在Lane的起点)</span><br><span class="line">  optional double end_s = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoutingRequest &#123;</span><br><span class="line">  optional apollo.common.Header header = 1;</span><br><span class="line">  // at least two points. The first is start point, the end is final point.</span><br><span class="line">  // The routing must go through each point in waypoint.</span><br><span class="line">  repeated LaneWaypoint waypoint = 2;</span><br><span class="line">  // Note: LaneSegment黑名单, 表示这些LaneSegment不能通过</span><br><span class="line">  repeated LaneSegment blacklisted_lane = 3;</span><br><span class="line">  // Note: Road黑名单, 表示这些Road中的所有Lane都不能通过</span><br><span class="line">  repeated string blacklisted_road = 4;</span><br><span class="line">  optional bool broadcast = 5 [default = true];</span><br><span class="line">  optional apollo.hdmap.ParkingSpace parking_space = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导航器-Navigator"><a href="#导航器-Navigator" class="headerlink" title="导航器(Navigator)"></a>导航器(Navigator)</h2><p><code>Navigator</code>是路由搜索的实施类，完成具体的路径搜索。<br><code>Navigator</code>对象在构造时，会从<code>routing_map</code>文件中加载routing地图，然后对原始的routing地图信息进行一些加工&amp;整合，形成<code>TopoGraph</code>(对应<code>Navigator</code>中的<code>graph_</code>成员变量)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: 加载原始(origin)拓扑地图</span></span><br><span class="line">Navigator::Navigator(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; topo_file_path) &#123;</span><br><span class="line">  Graph graph;</span><br><span class="line">  <span class="keyword">if</span> (!cyber::common::GetProtoFromFile(topo_file_path, &amp;graph)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to read topology graph from "</span> &lt;&lt; topo_file_path;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  graph_.reset(<span class="keyword">new</span> TopoGraph());</span><br><span class="line">  <span class="comment">// Note: 对base_map信息进行加工&amp;整合，形成拓扑图TopoGraph</span></span><br><span class="line">  <span class="keyword">if</span> (!graph_-&gt;LoadGraph(graph)) &#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Failed to init navigator graph failed! File path: "</span></span><br><span class="line">          &lt;&lt; topo_file_path;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  black_list_generator_.reset(<span class="keyword">new</span> BlackListRangeGenerator);</span><br><span class="line">  result_generator_.reset(<span class="keyword">new</span> ResultGenerator);</span><br><span class="line">  is_ready_ = <span class="literal">true</span>;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"The navigator is ready."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓扑图-TopoGraph"><a href="#拓扑图-TopoGraph" class="headerlink" title="拓扑图(TopoGraph)"></a>拓扑图(TopoGraph)</h2><p><code>routing_map</code>的数据结构类型为<code>Graph</code>(数据结构定义在<code>topo_graph.proto</code>中)，其中的Node表示一条语义地图中完整的Lane，而Edge表示Lane之间的拓扑关系。Routing模块并不直接使用Graph进行路由寻径，而使用了细节信息更丰富的<strong>TopoGraph</strong>。<code>TopoGraph</code>的全部信息都来源于<code>Graph</code>，但由于对原始的节点(<code>Node</code>)和连接边(Edge)信息进行了加工和整合，提供了许多额外的数据结构来方便后续的查找和搜索。<br>通过TopoGraph，你可以查找一个Lane Id对应的TopoNode是哪个，可以查找某个TopoNode的OutEdge(InEdge)有那些，这些OutEdge(InEdge)的另一边又是连接到哪条Lane上的，还可以查找某个Road Id对应的一系列TopoNode等。<br>这些TopoNode之间的拓扑关系表示的就是地图中Lane之间的关系。举个例子，在TopoGraph中TopoNode A(对应Lane A)有一条类型为LEFT的OutEdge连接到TopoNode B(对应Lane B)，表示在地图中Lane A的左边就是Lane B，B紧邻A。</p>
<h3 id="拓扑图-TopoGraph-加载流程"><a href="#拓扑图-TopoGraph-加载流程" class="headerlink" title="拓扑图(TopoGraph)加载流程"></a>拓扑图(TopoGraph)加载流程</h3><p><code>TopoGraph</code>头文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopoGraph</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  TopoGraph() = <span class="keyword">default</span>;</span><br><span class="line">  ~TopoGraph() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadGraph</span><span class="params">(<span class="keyword">const</span> Graph&amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">MapVersion</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">MapDistrict</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> TopoNode* <span class="title">GetNode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetNodesByRoadId</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; road_id,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">const</span> TopoNode*&gt;* <span class="keyword">const</span> node_in_road)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadNodes</span><span class="params">(<span class="keyword">const</span> Graph&amp; graph)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadEdges</span><span class="params">(<span class="keyword">const</span> Graph&amp; graph)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> map_version_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> map_district_;</span><br><span class="line">  <span class="comment">// Note: 存放所有从routing_map加载来的TopoNode</span></span><br><span class="line">  <span class="comment">// lane_id对应的TopoNode的下标可以通过lane_id查表node_index_map_得到</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TopoNode&gt; &gt; topo_nodes_;</span><br><span class="line">  <span class="comment">// Note: TopoEdge列表</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TopoEdge&gt; &gt; topo_edges_;</span><br><span class="line">  <span class="comment">// Note: lane_id对应的TopoNode在topo_nodes_中的下标</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; node_index_map_;</span><br><span class="line">  <span class="comment">// Note: road_id对应的TopoNode的集合</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">const</span> TopoNode*&gt; &gt;</span><br><span class="line">      road_node_map_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加载TopoGraph的过程比较简单，直接看代码和注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: 加载拓扑地图(origin TopoNode和origin TopoEdge)</span></span><br><span class="line"><span class="keyword">bool</span> TopoGraph::LoadGraph(<span class="keyword">const</span> Graph&amp; graph) &#123;</span><br><span class="line">  Clear();</span><br><span class="line"></span><br><span class="line">  map_version_ = graph.hdmap_version();</span><br><span class="line">  map_district_ = graph.hdmap_district();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!LoadNodes(graph)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to load nodes from topology graph."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!LoadEdges(graph)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to load edges from topology graph."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Load Topo data successful."</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: TopoNode初始化时会获取锚点, 对变道区间根据start_s进行排序</span></span><br><span class="line"><span class="comment">// 计算最长的边界range, 并分别判断左右两边的最大变道区间是否足够用于变道(长度超过设定值)</span></span><br><span class="line"><span class="comment">// TopoNode初始化时，还没有对有交集的变道区间进行合并</span></span><br><span class="line"><span class="keyword">bool</span> TopoGraph::LoadNodes(<span class="keyword">const</span> Graph&amp; graph) &#123;</span><br><span class="line">  <span class="keyword">if</span> (graph.node().empty()) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"No nodes found in topology graph."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : graph.node()) &#123;</span><br><span class="line">    node_index_map_[node.lane_id()] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(topo_nodes_.size());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TopoNode&gt; topo_node;</span><br><span class="line">    <span class="comment">// Note: TopoNode的构造函数做了不少东西，需要注意一下</span></span><br><span class="line">    topo_node.reset(<span class="keyword">new</span> TopoNode(node));</span><br><span class="line">    road_node_map_[node.road_id()].insert(topo_node.get());</span><br><span class="line">    topo_nodes_.push_back(<span class="built_in">std</span>::move(topo_node));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Need to execute load_nodes() firstly</span></span><br><span class="line"><span class="comment">// Note: 根据拓扑地图中的Edge形成TopoEdge并添加对应TopoNode的InEdge和OutEdge</span></span><br><span class="line"><span class="keyword">bool</span> TopoGraph::LoadEdges(<span class="keyword">const</span> Graph&amp; graph) &#123;</span><br><span class="line">  <span class="keyword">if</span> (graph.edge().empty()) &#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"0 edges found in topology graph, but it's fine"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : graph.edge()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; from_lane_id = edge.from_lane_id();</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; to_lane_id = edge.to_lane_id();</span><br><span class="line">    <span class="keyword">if</span> (node_index_map_.count(from_lane_id) != <span class="number">1</span> ||</span><br><span class="line">        node_index_map_.count(to_lane_id) != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TopoEdge&gt; topo_edge;</span><br><span class="line">    TopoNode* from_node = topo_nodes_[node_index_map_[from_lane_id]].get();</span><br><span class="line">    TopoNode* to_node = topo_nodes_[node_index_map_[to_lane_id]].get();</span><br><span class="line">    topo_edge.reset(<span class="keyword">new</span> TopoEdge(edge, from_node, to_node));</span><br><span class="line">    from_node-&gt;AddOutEdge(topo_edge.get());</span><br><span class="line">    to_node-&gt;AddInEdge(topo_edge.get());</span><br><span class="line">    topo_edges_.push_back(<span class="built_in">std</span>::move(topo_edge));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Routing搜索流程"><a href="#Routing搜索流程" class="headerlink" title="Routing搜索流程"></a>Routing搜索流程</h2><p>先说明一下路径搜索的大致流程。</p>
<ol>
<li>获取waypoints所在的Lane对应的TopoNode，这样就把航点映射到TopoGraph中了。</li>
<li>添加黑名单。Apollo支持在RoutingRequest中添加黑名单，表示那些车道段(LaneSegment)和Road是不能通行的，这样做的意义在于可以避开拥堵路段/施工路段之类的无法通行的区域。</li>
<li>依次搜索前后两个航点之间的路径，最后把这些路径拼接起来。这样可以处理带有多个航点(waypoint)的路径搜索。通俗一点，查找<code>深圳--&gt;东莞--&gt;广州</code>的路径，就是搜索<code>深圳--&gt;东莞</code>和<code>东莞--&gt;广州</code>，然后把两段结果拼接起来。</li>
<li>将路径搜索的结果输出为RoutingResponse的格式。</li>
</ol>
<h3 id="将航点映射到TopoGraph中的TopoNode"><a href="#将航点映射到TopoGraph中的TopoNode" class="headerlink" title="将航点映射到TopoGraph中的TopoNode"></a>将航点映射到TopoGraph中的TopoNode</h3><p>获取waypoints对应的TopoNode，抽取waypoint在对应Lane中的s：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Navigator::Init(<span class="keyword">const</span> RoutingRequest&amp; request, <span class="keyword">const</span> TopoGraph* graph,</span><br><span class="line">                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt;* <span class="keyword">const</span> way_nodes,</span><br><span class="line">                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;* <span class="keyword">const</span> way_s) &#123;</span><br><span class="line">  Clear();</span><br><span class="line">  <span class="comment">// Note: 获取waypoints对应的TopoNode和waypoint在对应Lane中的s</span></span><br><span class="line">  <span class="keyword">if</span> (!GetWayNodes(request, graph_.get(), way_nodes, way_s)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to find search terminal point in graph!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetWayNodes</span><span class="params">(<span class="keyword">const</span> RoutingRequest&amp; request, <span class="keyword">const</span> TopoGraph* graph,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt;* <span class="keyword">const</span> way_nodes,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;* <span class="keyword">const</span> way_s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point : request.waypoint()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* cur_node = graph-&gt;GetNode(point.id());</span><br><span class="line">    <span class="keyword">if</span> (cur_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Cannot find way point in graph! Id: "</span> &lt;&lt; point.id();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    way_nodes-&gt;push_back(cur_node);</span><br><span class="line">    way_s-&gt;push_back(point.s());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="黑名单管理"><a href="#黑名单管理" class="headerlink" title="黑名单管理"></a>黑名单管理</h3><p>进行路径搜索前会添加在RoutingRequest中指定的黑名单，RoutingRequest指定黑名单的方式有两种：</p>
<ul>
<li>指定不能通行的车道段(LaneSegment)。LaneSegment表示Lane的一部分。</li>
<li>指定不能通行的Road。该Road Id对应的Road包含的所有Lane都不能通行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Navigator::Init(<span class="keyword">const</span> RoutingRequest&amp; request, <span class="keyword">const</span> TopoGraph* graph,</span><br><span class="line">                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt;* <span class="keyword">const</span> way_nodes,</span><br><span class="line">                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;* <span class="keyword">const</span> way_s) &#123;</span><br><span class="line">  <span class="comment">// 省略。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 从request中获取黑名单</span></span><br><span class="line">  black_list_generator_-&gt;GenerateBlackMapFromRequest(request, graph_.get(),</span><br><span class="line">                                                     &amp;topo_range_manager_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlackListRangeGenerator::GenerateBlackMapFromRequest(</span><br><span class="line">    <span class="keyword">const</span> RoutingRequest&amp; request, <span class="keyword">const</span> TopoGraph* graph,</span><br><span class="line">    TopoRangeManager* <span class="keyword">const</span> range_manager) <span class="keyword">const</span> &#123;</span><br><span class="line">  AddBlackMapFromLane(request, graph, range_manager);</span><br><span class="line">  AddBlackMapFromRoad(request, graph, range_manager);</span><br><span class="line">  <span class="comment">// Note: 对range_map_里面的TopoNode的NodeSRange进行排序, 然后进行区间合并</span></span><br><span class="line">  range_manager-&gt;SortAndMerge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TopoRangeManager</code>管理着所有的黑名单，黑名单就是TopoNode对应的黑名单区间NodeSRange。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopoRangeManager</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> TopoNode*, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeSRange&gt;&gt;&amp; RangeMap()</span><br><span class="line">      <span class="keyword">const</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeSRange&gt;* Find(<span class="keyword">const</span> TopoNode* node) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> TopoNode* node, <span class="keyword">double</span> start_s, <span class="keyword">double</span> end_s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SortAndMerge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Note: TopoNode对应的一系列黑名单NodeSRange(不允许通行)</span></span><br><span class="line">  <span class="comment">// 在BlackListRangeGenerator中添加的NodeSRange黑名单</span></span><br><span class="line">  <span class="comment">// 这里的TopoNode指针还是刚开始加载拓扑地图后的TopoNode的指针</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> TopoNode*, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeSRange&gt;&gt; range_map_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑子图-SubTopoGraph"><a href="#拓扑子图-SubTopoGraph" class="headerlink" title="拓扑子图(SubTopoGraph)"></a>拓扑子图(SubTopoGraph)</h3><p>加入黑名单之后带来了一个新的问题，TopoGraph里面的TopoNode可能是带有黑名单LaneSegment的(对应TopoRangeManager里的NodeSRange)，而我们最后输出的行车路径中不应该包含这些黑名单LaneSegment，因此进行拓扑图搜索时应该避免对黑名单路段进行搜索，这使得TopoGraph因缺乏黑名单信息而变得不够完整了，甚至无法判断原来连通的两个TopoNode在加入黑名单之后是否已经变得不连通。Apollo中通过引入拓扑子图(<code>SubTopoGraph</code>)来解决这个问题。SubTopoGraph只关注那些不完整的Lane对应的TopoNode，不完整的Lane有两种，带黑名单的Lane和waypoint所在的Lane&amp;同向Lane。</p>
<h4 id="创建拓扑子图-SubTopoGraph"><a href="#创建拓扑子图-SubTopoGraph" class="headerlink" title="创建拓扑子图(SubTopoGraph)"></a>创建拓扑子图(SubTopoGraph)</h4><p>在注释中，我把TopoGraph中的TopoNode称为origin TopoNode，代表的是对应整条Lane的TopoNode，TopoGraph中的TopoEdge称为origin TopoEdge。把拓扑子图(SubTopoGraph)中创建的TopoNode称为子TopoNode，子图中创建的TopoEdge称为子TopoEdge。<br>拓扑子图只管包含黑名单LaneSegment的TopoGraph中的TopoNode对应的Lane，将这些Lane中的黑名单剔除，提取出白名单(可供行驶的LaneSegment)，根据白名单创建子TopoNode。需要特别注意的是，在SubTopoGraph中创建的子TopoNode和子TopoEdge信息不会添加到TopoGraph中，TopoGraph的信息自从<code>routing_map</code>中加载完成后就不再改变了。为了将子图SubTopoGraph与TopoGraph联系起来，需要在拓扑子图(SubTopoGraph)中添加从子TopoNode连接到TopoGraph的TopoNode的连接信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SubTopoGraph::SubTopoGraph(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> TopoNode*, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeSRange&gt; &gt;&amp;</span><br><span class="line">        black_map) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeSRange&gt; valid_range;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; map_iter : black_map) &#123;</span><br><span class="line">    valid_range.clear();</span><br><span class="line">    <span class="comment">// Note: 过滤TopoNode处于黑名单的NodeSRange, 从而获得TopoNode的有效NodeSRange</span></span><br><span class="line">    GetSortedValidRange(map_iter.first, map_iter.second, &amp;valid_range);</span><br><span class="line">    <span class="comment">// Note: 为TopoNode的每个valid range都创建一个对应range的子TopoNode</span></span><br><span class="line">    <span class="comment">// 如果两个子TopoNode是紧邻的, 则在两个TopoNode之间添加Edge</span></span><br><span class="line">    <span class="comment">// 使得之前被分割的waypoint起点和终点前后的平行车道的子TopoNode重新连接起来了</span></span><br><span class="line">    InitSubNodeByValidRange(map_iter.first, valid_range);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 创建黑名单中的origin TopoNode的有效子TopoNode的连接边(子TopoEdge)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; map_iter : black_map) &#123;</span><br><span class="line">    InitSubEdge(map_iter.first);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与InitSubEdge里面判断能否变道的标准有一些不同, AddPotentialEdge的变道区间下限为3m</span></span><br><span class="line">  <span class="comment">// 把一些可能在InitSubEdge因变道区间不足而不被添加的边添加进来</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; map_iter : black_map) &#123;</span><br><span class="line">    AddPotentialEdge(map_iter.first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="拓扑子图-SubTopoGraph-中的TopoNode"><a href="#拓扑子图-SubTopoGraph-中的TopoNode" class="headerlink" title="拓扑子图(SubTopoGraph)中的TopoNode"></a>拓扑子图(SubTopoGraph)中的TopoNode</h5><p>SubTopoGraph中的TopoNode通过过滤origin TopoNode中的黑名单LaneSegment得到的白名单(Valid Range)来创建，表示一段可通行的LaneSegment。<br>创建TopoNode时记录了该TopoNode表示的LaneSegment的区间范围([start_s_, end_s_])，还会找该LaneSegment的中心点(AnchorPoint/锚点)，并且计算该TopoNode的可变道区间列表。[注释: 后面通过AnchorPoint之间的距离来估算TopoNode之间的直线距离]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: TopoGraph从routing_map加载拓扑地图时TopoNode使用这种初始化方式</span></span><br><span class="line"><span class="comment">// TopoNode初始化时会获取锚点, 对变道区间根据start_s进行排序</span></span><br><span class="line"><span class="comment">// 计算最长的边界range, 并分别判断左右两边的最大变道区间是否足够用于变道</span></span><br><span class="line"><span class="comment">// 变道区间此处未进行交集合并处理</span></span><br><span class="line">TopoNode::TopoNode(<span class="keyword">const</span> Node&amp; node)</span><br><span class="line">    : pb_node_(node), start_s_(<span class="number">0.0</span>), end_s_(pb_node_.length()) &#123;</span><br><span class="line">  CHECK(pb_node_.length() &gt; kLenghtEpsilon)</span><br><span class="line">      &lt;&lt; <span class="string">"Node length is invalid in pb: "</span> &lt;&lt; pb_node_.DebugString();</span><br><span class="line">  Init();</span><br><span class="line">  <span class="comment">// origin_node_是否等于this是判断当前TopoNode是不是SubTopoGraph中的TopoNode的标志</span></span><br><span class="line">  origin_node_ = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: 这个构造函数在创建SubTopoGraph时使用</span></span><br><span class="line">TopoNode::TopoNode(<span class="keyword">const</span> TopoNode* topo_node, <span class="keyword">const</span> NodeSRange&amp; range)</span><br><span class="line">    : TopoNode(topo_node-&gt;PbNode()) &#123;</span><br><span class="line">  origin_node_ = topo_node;</span><br><span class="line">  start_s_ = range.StartS();</span><br><span class="line">  end_s_ = range.EndS();</span><br><span class="line">  Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: 找TopoNode对应的LaneSegment中心线的中间点作为锚点</span></span><br><span class="line"><span class="comment">// 找左右虚线边界最长的range, 并简单地通过长度判断是否足够用于lane change</span></span><br><span class="line"><span class="keyword">void</span> TopoNode::Init() &#123;</span><br><span class="line">  <span class="comment">// Note: 将s range中间的点设置为anchor point</span></span><br><span class="line">  <span class="keyword">if</span> (!FindAnchorPoint()) &#123;</span><br><span class="line">    AWARN &lt;&lt; <span class="string">"Be attention!!! Find anchor point failed for lane: "</span> &lt;&lt; LaneId();</span><br><span class="line">  &#125;</span><br><span class="line">  ConvertOutRange(pb_node_.left_out(), start_s_, end_s_,</span><br><span class="line">                  &amp;left_out_sorted_range_, &amp;left_prefer_range_index_);</span><br><span class="line"></span><br><span class="line">  is_left_range_enough_ =</span><br><span class="line">      (left_prefer_range_index_ &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      left_out_sorted_range_[left_prefer_range_index_].IsEnoughForChangeLane();</span><br><span class="line"></span><br><span class="line">  ConvertOutRange(pb_node_.right_out(), start_s_, end_s_,</span><br><span class="line">                  &amp;right_out_sorted_range_, &amp;right_prefer_range_index_);</span><br><span class="line">  is_right_range_enough_ = (right_prefer_range_index_ &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                           right_out_sorted_range_[right_prefer_range_index_]</span><br><span class="line">                               .IsEnoughForChangeLane();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="拓扑子图-SubTopoGraph-中的TopoEdge"><a href="#拓扑子图-SubTopoGraph-中的TopoEdge" class="headerlink" title="拓扑子图(SubTopoGraph)中的TopoEdge"></a>拓扑子图(SubTopoGraph)中的TopoEdge</h5><p>子图TopoEdge的创建稍微复杂一点，处理逻辑是，对于每一个子TopoNode(简称<code>Sub_A</code>)，其所在的origin TopoNode称为<code>A</code>，TopoGraph中与<code>A</code>相连的TopoNode有多个(<code>B,C,...</code>等)，对每一个与<code>A</code>相连的origin TopoNode(假设是<code>B</code>)，根据变道条件判断<code>Sub_A</code>能否通过变道(或直行)与<code>B</code>的子TopoNode相连(假设为<code>Sub_B</code>)，如果可以连接，则创建子TopoEdge，将子TopoEdge信息添加到<code>Sub_A</code>和<code>Sub_B</code>的InEdge/OutEdge集合中。假如<code>B</code>没有子TopoNode(表示<code>B</code>没有黑名单)，那就判断<code>Sub_A</code>能否通过变道(或直行)与<code>B</code>相连，如果可以连接，则创建子TopoEdge，将子TopoEdge信息添加到<code>Sub_A</code>的InEdge/OutEdge集合中。注意，子TopoEdge信息始终没有添加到origin TopoNode的Edge信息中。</p>
<h3 id="分段进行路径搜索"><a href="#分段进行路径搜索" class="headerlink" title="分段进行路径搜索"></a>分段进行路径搜索</h3><p>Routing是依次搜索前后两个航点之间的路径，每一次搜索(每两个相邻航点之间的路径搜索)都会重新建立拓扑子图。每轮搜索的起点和终点处的Lane(以及同向车道)都被分割成两部分了，导致了每轮搜索所建立的子图是不一样的。<br>搜索的起点(<code>start</code>)和终点(<code>end</code>)都是子TopoNode，因为<code>way_start</code>和<code>way_end</code>这两个origin TopoNode都通过<code>AddBlackMapFromTerminal</code>添加了一段长度为0的黑名单区间，从而将起点和终点处的TopoNode分割成两个子TopoNode了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Navigator::SearchRouteByStrategy(</span><br><span class="line">    <span class="keyword">const</span> TopoGraph* graph, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt;&amp; way_nodes,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; way_s,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt;* <span class="keyword">const</span> result_nodes) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Strategy&gt; strategy_ptr;</span><br><span class="line">  strategy_ptr.reset(<span class="keyword">new</span> AStarStrategy(FLAGS_enable_change_lane_in_result));</span><br><span class="line"></span><br><span class="line">  result_nodes-&gt;clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt; node_vec;</span><br><span class="line">  <span class="comment">// Note: 分段进行路由搜索</span></span><br><span class="line">  <span class="comment">// Note: 在每轮循环中都建立拓扑子图，然后进行路由搜索</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; way_nodes.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* way_start = way_nodes[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* way_end = way_nodes[i];</span><br><span class="line">    <span class="keyword">double</span> way_start_s = way_s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">double</span> way_end_s = way_s[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: 黑名单管理</span></span><br><span class="line">    <span class="comment">// topo_range_manager_只有从routing request中制定的LaneSegment和Road黑名单</span></span><br><span class="line">    <span class="comment">// full_range_manager会在waypoint所在车道&amp;平行车道前后添加新的黑名单</span></span><br><span class="line">    TopoRangeManager full_range_manager = topo_range_manager_;</span><br><span class="line">    <span class="comment">// Note: 在当前Lane和平行车道Lane的</span></span><br><span class="line">    <span class="comment">// way_start_s的后面(-1cm)和way_end_s的前面(+1cm)设置黑名单</span></span><br><span class="line">    <span class="comment">// 但这里通过AddBlackMapFromTerminal加入的黑名单NodeSRange的长度都是0</span></span><br><span class="line">    <span class="comment">// 举个例子, [3.21, 3.21]</span></span><br><span class="line">    <span class="comment">// Note: way_start这个TopoNode会产生两个子TopoNode，</span></span><br><span class="line">    <span class="comment">// 分别是[0, way_start_s - 1cm]和[way_start_s - 1cm, length]</span></span><br><span class="line">    <span class="comment">// 这里单纯就为了将waypoint所在Lane(以及同向车道)分割成两部分子TopoNode，</span></span><br><span class="line">    <span class="comment">// 从而获得搜索起点start和搜索终点end</span></span><br><span class="line">    black_list_generator_-&gt;AddBlackMapFromTerminal(</span><br><span class="line">        way_start, way_end, way_start_s, way_end_s, &amp;full_range_manager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: 创建子图, 里面包含黑名单origin TopoNode的有效子TopoNode的信息和关联的TopoEdge信息</span></span><br><span class="line">    <span class="comment">// 子图与origin TopoNode是相关联的,</span></span><br><span class="line">    <span class="comment">// 子图里面的TopoNode都是黑名单里面那些valid range生成的TopoNode(称为子TopoNode或sub TopoNode)</span></span><br><span class="line">    <span class="comment">// 在创建子TopoEdge时, 根据sub TopoNode所在的origin TopoNode连接的所有的connected origin TopoNode来创建,</span></span><br><span class="line">    <span class="comment">// 如果connected origin TopoNode没有sub TopoNode,</span></span><br><span class="line">    <span class="comment">// 则直接创建sub TopoEdge连接sub TopoNode和connected origin TopoNode</span></span><br><span class="line">    <span class="comment">// 如果connected origin TopoNode有sub TopoNode,</span></span><br><span class="line">    <span class="comment">// 则判断每个sub TopoNode是否可能与当前的sub TopoNode连接上(符合变道或直行的要求)</span></span><br><span class="line">    <span class="comment">// 总的来说, SubTopoGraph包含了所有的sub TopoNode和所有的sub TopoEdge,</span></span><br><span class="line">    <span class="comment">// 这些sub TopoEdge连接的其中一端肯定是sub TopoNode, 另一端则有可能是origin/sub TopoNode</span></span><br><span class="line">    <span class="comment">// 子TopoEdge的信息被添加到子TopoNode中,</span></span><br><span class="line">    <span class="comment">// 但origin TopoNode不会添加子TopoEdge到InEdge或OutEdge信息中</span></span><br><span class="line">    <span class="function">SubTopoGraph <span class="title">sub_graph</span><span class="params">(full_range_manager.RangeMap())</span></span>;</span><br><span class="line">    <span class="comment">// Note: 起点处的子TopoNode</span></span><br><span class="line">    <span class="comment">// 这个子TopoNode包含了起点waypoint的点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* start = sub_graph.GetSubNodeWithS(way_start, way_start_s);</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Sub graph node is nullptr, origin node id: "</span></span><br><span class="line">             &lt;&lt; way_start-&gt;LaneId() &lt;&lt; <span class="string">", s:"</span> &lt;&lt; way_start_s;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: 终点处的子TopoNode</span></span><br><span class="line">    <span class="comment">// 这个子TopoNode包含了终点处的waypoint</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* end = sub_graph.GetSubNodeWithS(way_end, way_end_s);</span><br><span class="line">    <span class="keyword">if</span> (end == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Sub graph node is nullptr, origin node id: "</span></span><br><span class="line">             &lt;&lt; way_end-&gt;LaneId() &lt;&lt; <span class="string">", s:"</span> &lt;&lt; way_end_s;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt; cur_result_nodes;</span><br><span class="line">    <span class="keyword">if</span> (!strategy_ptr-&gt;Search(graph, &amp;sub_graph, start, end,</span><br><span class="line">                              &amp;cur_result_nodes)) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Failed to search route with waypoint from "</span> &lt;&lt; start-&gt;LaneId()</span><br><span class="line">             &lt;&lt; <span class="string">" to "</span> &lt;&lt; end-&gt;LaneId();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node_vec.insert(node_vec.end(), cur_result_nodes.begin(),</span><br><span class="line">                    cur_result_nodes.end());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 合并多段waypoint之间的路由结果</span></span><br><span class="line">  <span class="comment">// Note: 这里把被middle waypoints分割的LaneSegment重新组合成一段LaneSegment了</span></span><br><span class="line">  <span class="keyword">if</span> (!MergeRoute(node_vec, result_nodes)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to merge route."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AStarStrategy"><a href="#AStarStrategy" class="headerlink" title="AStarStrategy"></a>AStarStrategy</h3><p>Apollo Routing模块使用经典的<code>A*</code>搜索来进行路径查找，关于<code>A*</code>的讲解网上可以找到非常多的资料。节点的代价函数由$F(x) = G(x) + H(x)$决定，$G$是从起点到达当前节点的实际代价，$H$是估计的从当前节点到终点的代价(通过欧式距离估算)。基本策略就是维持一个节点的优先队列，每次将代价最小($F$最小)的TopoNode出列。为了能够在搜索到终点时重建搜索的路径，需要将当前节点的来源节点记录下来(代码中的<code>came_from_</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: 搜索两个waypoint(TopoNode)之间的可行路径</span></span><br><span class="line"><span class="comment">// graph: 拓扑图</span></span><br><span class="line"><span class="comment">// sub_graph: 子拓扑图(子图)</span></span><br><span class="line"><span class="comment">// src_node: 起点waypoint所在的子TopoNode,</span></span><br><span class="line"><span class="comment">// 一般来说，src_node区间范围是[start_s - 1cm, length]</span></span><br><span class="line"><span class="comment">// dest_node: 终点waypoint所在的子TopoNode,</span></span><br><span class="line"><span class="comment">// 一般来说，dest_node区间范围是[0, end_s + 1cm]</span></span><br><span class="line"><span class="comment">// 最终输出从src_node到dest_node的NodeWithRange序列</span></span><br><span class="line"><span class="comment">// 这个result_nodes记录的是从src_node到dest_node(可能)经过的LaneSegment</span></span><br><span class="line"><span class="comment">// result_nodes中的NodeWithRange里面的TopoNode都是origin TopoNode</span></span><br><span class="line"><span class="keyword">bool</span> AStarStrategy::Search(<span class="keyword">const</span> TopoGraph* graph,</span><br><span class="line">                           <span class="keyword">const</span> SubTopoGraph* sub_graph,</span><br><span class="line">                           <span class="keyword">const</span> TopoNode* src_node, <span class="keyword">const</span> TopoNode* dest_node,</span><br><span class="line">                           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt;* <span class="keyword">const</span> result_nodes) &#123;</span><br><span class="line">  Clear();</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Start A* search algorithm."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::priority_queue&lt;SearchNode&gt; open_set_detail;</span><br><span class="line"></span><br><span class="line">  <span class="function">SearchNode <span class="title">src_search_node</span><span class="params">(src_node)</span></span>;</span><br><span class="line">  <span class="comment">// Note: f = g + h, 起点的g = 0</span></span><br><span class="line">  src_search_node.f = HeuristicCost(src_node, dest_node);</span><br><span class="line">  open_set_detail.push(src_search_node);</span><br><span class="line"></span><br><span class="line">  open_set_.insert(src_node);</span><br><span class="line">  g_score_[src_node] = <span class="number">0.0</span>;</span><br><span class="line">  enter_s_[src_node] = src_node-&gt;StartS();</span><br><span class="line"></span><br><span class="line">  SearchNode current_node;</span><br><span class="line">  <span class="comment">// Note: 所有从当前node出发的edge</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">const</span> TopoEdge*&gt; next_edge_set;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">const</span> TopoEdge*&gt; sub_edge_set;</span><br><span class="line">  <span class="keyword">while</span> (!open_set_detail.empty()) &#123;</span><br><span class="line">    current_node = open_set_detail.top();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* from_node = current_node.topo_node;</span><br><span class="line">    <span class="comment">// Note: 搜索到终点</span></span><br><span class="line">    <span class="keyword">if</span> (current_node.topo_node == dest_node) &#123;</span><br><span class="line">      <span class="comment">// Note: 根据搜索的中间信息输出路径规划结果</span></span><br><span class="line">      <span class="keyword">if</span> (!Reconstruct(came_from_, from_node, result_nodes)) &#123;</span><br><span class="line">        AERROR &lt;&lt; <span class="string">"Failed to reconstruct route."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    open_set_.erase(from_node);</span><br><span class="line">    open_set_detail.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closed_set_.count(from_node) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// if showed before, just skip...</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closed_set_.emplace(from_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if residual_s is less than FLAGS_min_length_for_lane_change, only move</span></span><br><span class="line">    <span class="comment">// forward</span></span><br><span class="line">    <span class="comment">// 根据剩余距离是否足够变道来筛选下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor_edges =</span><br><span class="line">        (GetResidualS(from_node) &gt; FLAGS_min_length_for_lane_change &amp;&amp;</span><br><span class="line">         change_lane_enabled_)</span><br><span class="line">            ? from_node-&gt;OutToAllEdge()</span><br><span class="line">            : from_node-&gt;OutToSucEdge();</span><br><span class="line">    <span class="keyword">double</span> tentative_g_score = <span class="number">0.0</span>;</span><br><span class="line">    next_edge_set.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* edge : neighbor_edges) &#123;</span><br><span class="line">      sub_edge_set.clear();</span><br><span class="line">      <span class="comment">// Note: 本质上只是获取从from_node出发的Edge</span></span><br><span class="line">      sub_graph-&gt;GetSubInEdgesIntoSubGraph(edge, &amp;sub_edge_set);</span><br><span class="line">      next_edge_set.insert(sub_edge_set.begin(), sub_edge_set.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: 所有从当前node出发的edge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* edge : next_edge_set) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>* to_node = edge-&gt;ToNode();</span><br><span class="line">      <span class="comment">// Note: 已经访问过, 访问过的node的cost不会比当前的cost高</span></span><br><span class="line">      <span class="keyword">if</span> (closed_set_.count(to_node) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (GetResidualS(edge, to_node) &lt; FLAGS_min_length_for_lane_change) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tentative_g_score =</span><br><span class="line">          g_score_[current_node.topo_node] + GetCostToNeighbor(edge);</span><br><span class="line">      <span class="comment">// Note: 如果是变道类型的Edge，两条道不是都走完全程的，节点自身的cost只取一半</span></span><br><span class="line">      <span class="comment">// 通俗一点的说法就是，我从A变道到B，我的行驶路程并没有Lane A + Lane B的总长度这么长</span></span><br><span class="line">      <span class="comment">// 大概就是一半这样子</span></span><br><span class="line">      <span class="keyword">if</span> (edge-&gt;Type() != TopoEdgeType::TET_FORWARD) &#123;</span><br><span class="line">        tentative_g_score -=</span><br><span class="line">            (edge-&gt;FromNode()-&gt;Cost() + edge-&gt;ToNode()-&gt;Cost()) / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">double</span> f = tentative_g_score + HeuristicCost(to_node, dest_node);</span><br><span class="line">      <span class="comment">// Note: 如果发现to_node已经处于搜索边界且已知的cost比从当前节点出发的cost要小</span></span><br><span class="line">      <span class="keyword">if</span> (open_set_.count(to_node) != <span class="number">0</span> &amp;&amp; f &gt;= g_score_[to_node]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Note: 估计进入to_node时的位置</span></span><br><span class="line">      <span class="comment">// if to_node is reached by forward, reset enter_s to start_s</span></span><br><span class="line">      <span class="keyword">if</span> (edge-&gt;Type() == TopoEdgeType::TET_FORWARD) &#123;</span><br><span class="line">        enter_s_[to_node] = to_node-&gt;StartS();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// else, add enter_s with FLAGS_min_length_for_lane_change</span></span><br><span class="line">        <span class="comment">// Note: 估算变道进入to_node的位置</span></span><br><span class="line">        <span class="keyword">double</span> to_node_enter_s =</span><br><span class="line">            (enter_s_[from_node] + FLAGS_min_length_for_lane_change) /</span><br><span class="line">            from_node-&gt;Length() * to_node-&gt;Length();</span><br><span class="line">        <span class="comment">// enter s could be larger than end_s but should be less than length</span></span><br><span class="line">        to_node_enter_s = <span class="built_in">std</span>::min(to_node_enter_s, to_node-&gt;Length());</span><br><span class="line">        <span class="comment">// if enter_s is larger than end_s and to_node is dest_node</span></span><br><span class="line">        <span class="keyword">if</span> (to_node_enter_s &gt; to_node-&gt;EndS() &amp;&amp; to_node == dest_node) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        enter_s_[to_node] = to_node_enter_s;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      g_score_[to_node] = f;</span><br><span class="line">      <span class="function">SearchNode <span class="title">next_node</span><span class="params">(to_node)</span></span>;</span><br><span class="line">      next_node.f = f;</span><br><span class="line">      open_set_detail.push(next_node);</span><br><span class="line">      <span class="comment">// Note: 记录父节点</span></span><br><span class="line">      came_from_[to_node] = from_node;</span><br><span class="line">      <span class="keyword">if</span> (open_set_.count(to_node) == <span class="number">0</span>) &#123;</span><br><span class="line">        open_set_.insert(to_node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  AERROR &lt;&lt; <span class="string">"Failed to find goal lane with id: "</span> &lt;&lt; dest_node-&gt;LaneId();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">搜索到终点后需要根据父节点信息重构完整的路径，这个Reconstruct的过程对变道(lane change)的节点做了调整，调整的意义在于选择更长的节点(Lane)作为变道的节点。</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line"><span class="comment">// Note: 在发生变道的路由段做处理，选择更长的节点作为变道区间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AdjustLaneChange</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt;* <span class="keyword">const</span> result_node_vec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result_node_vec-&gt;size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Note: 从后往前检查，尝试将变道的地点往终点方向移动到更合适的位置(更长的Lane)</span></span><br><span class="line">  <span class="keyword">if</span> (!AdjustLaneChangeBackward(result_node_vec)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to adjust lane change backward"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Note: 从前往后检查，尝试将变道的地点往起点方向移动到更合适的位置(更长的Lane)</span></span><br><span class="line">  <span class="keyword">if</span> (!AdjustLaneChangeForward(result_node_vec)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to adjust lane change backward"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: 根据came_from信息抽取完整的行车路径</span></span><br><span class="line"><span class="comment">// Note: 对发生变道的路由段做处理，选择前方/后方更长的节点作为变道区间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reconstruct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> TopoNode*, <span class="keyword">const</span> TopoNode*&gt;&amp; came_from,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> TopoNode* dest_node, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt;* result_nodes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt; result_node_vec;</span><br><span class="line">  result_node_vec.push_back(dest_node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = came_from.find(dest_node);</span><br><span class="line">  <span class="keyword">while</span> (iter != came_from.end()) &#123;</span><br><span class="line">    result_node_vec.push_back(iter-&gt;second);</span><br><span class="line">    iter = came_from.find(iter-&gt;second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::reverse(result_node_vec.begin(), result_node_vec.end());</span><br><span class="line">  <span class="comment">// Note: 对发生变道的路由段做处理，选择前方/后方更长的节点作为变道区间</span></span><br><span class="line">  <span class="keyword">if</span> (!AdjustLaneChange(&amp;result_node_vec)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to adjust lane change"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result_nodes-&gt;clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* node : result_node_vec) &#123;</span><br><span class="line">    <span class="comment">// Note: result_nodes中的TopoNode都是origin TopoNode</span></span><br><span class="line">    result_nodes-&gt;emplace_back(node-&gt;OriginNode(), node-&gt;StartS(),</span><br><span class="line">                               node-&gt;EndS());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Routing结果输出"><a href="#Routing结果输出" class="headerlink" title="Routing结果输出"></a>Routing结果输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Navigator::SearchRoute(<span class="keyword">const</span> RoutingRequest&amp; request,</span><br><span class="line">                            RoutingResponse* <span class="keyword">const</span> response) &#123;</span><br><span class="line">  <span class="comment">// Note: 打印routing request信息</span></span><br><span class="line">  <span class="keyword">if</span> (!ShowRequestInfo(request, graph_.get())) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_REQUEST,</span><br><span class="line">                 <span class="string">"Error encountered when reading request point!"</span>,</span><br><span class="line">                 response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IsReady()) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_NOT_READY, <span class="string">"Navigator is not ready!"</span>,</span><br><span class="line">                 response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> TopoNode*&gt; way_nodes;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; way_s;</span><br><span class="line">  <span class="comment">// Note: 将routing request的waypoints信息转化为origin TopoNode和对应的s</span></span><br><span class="line">  <span class="comment">// 实际上就是去graph_里面去找waypoint的(Lane)id对应的TopoNode</span></span><br><span class="line">  <span class="comment">// 还添加了request指定的黑名单</span></span><br><span class="line">  <span class="keyword">if</span> (!Init(request, graph_.get(), &amp;way_nodes, &amp;way_s)) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_NOT_READY,</span><br><span class="line">                 <span class="string">"Failed to initialize navigator!"</span>, response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeWithRange&gt; result_nodes;</span><br><span class="line">  <span class="keyword">if</span> (!SearchRouteByStrategy(graph_.get(), way_nodes, way_s, &amp;result_nodes)) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_RESPONSE,</span><br><span class="line">                 <span class="string">"Failed to find route with request!"</span>,</span><br><span class="line">                 response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result_nodes.empty()) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_RESPONSE, <span class="string">"Failed to result nodes!"</span>,</span><br><span class="line">                 response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把起点和终点的前后1cm的多余距离抹除了</span></span><br><span class="line">  result_nodes.front().SetStartS(request.waypoint().begin()-&gt;s());</span><br><span class="line">  result_nodes.back().SetEndS(request.waypoint().rbegin()-&gt;s());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: result_nodes中的NodeWithRange的TopoNode都用的是原TopoGraph中的origin TopoNode</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 注意，这里传入的是routing request中黑名单建立的黑名单管理器</span></span><br><span class="line">  <span class="comment">// 将SearchRouteByStrategy的搜索结果转化为RoutingResponse形式</span></span><br><span class="line">  <span class="keyword">if</span> (!result_generator_-&gt;GeneratePassageRegion(</span><br><span class="line">          graph_-&gt;MapVersion(), request, result_nodes, topo_range_manager_,</span><br><span class="line">          response)) &#123;</span><br><span class="line">    SetErrorCode(ErrorCode::ROUTING_ERROR_RESPONSE,</span><br><span class="line">                 <span class="string">"Failed to generate passage regions based on result lanes"</span>,</span><br><span class="line">                 response-&gt;mutable_status());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SetErrorCode(ErrorCode::OK, <span class="string">"Success!"</span>, response-&gt;mutable_status());</span><br><span class="line"></span><br><span class="line">  PrintDebugData(result_nodes);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GeneratePassageRegion</code>的过程比较繁琐，大致过程就是先将路径分割成passage，然后对passage进行扩展，最后将passage结果转化成RoutingResponse需要的形式。<br><code>passage</code>在这里的概念就是一系列头尾相连的Lane，例如<code>A--&gt;B--&gt;C--&gt;D</code>，中间不涉及换道。用短横线<code>-</code>代表Lane，下图描述了SearchRouteByStrategy的结果，<br>结果中包含了4个passage，第一个passage包含6条头尾连接的Lane，第一个passage(的最后一条Lane)右转进入第二个passage(包含11条Lane)，第二个passage(的最后一条Lane)右转进入第三个passage(包含12条Lane),第三个passage(的最后一条Lane)左转进入第四个passage(包含10条Lane)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------</span><br><span class="line">     -----------          ----------</span><br><span class="line">               ------------</span><br><span class="line"></span><br><span class="line">行驶方向&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>SearchRouteByStrategy</code>中对拓扑图进行搜索时，变道就是一个TopoNode通过<code>LEFT/RIGHT</code>类型的TopoEdge连接到下一个TopoNode，这种形式的连接导致了变道的产生，但也规定了变道只能从passage的最后一个Lane开始，然后变道到下一个passage的第一条Lane，就如同上面简单画图表现的结果。我们希望可以将变道区间进行扩展，可以尝试根据将passage的前后进行扩展(<code>ResultGenerator</code>类的<code>ExtendPassages</code>方法)。当然了，在passage尾部扩展的Lane必须是能变道到下一个passage的，而在passage头部扩展的Lane必须是可以从上一passage变道进入的。扩展完成后的结果可能是下面这样子，经过扩展的那些passage的Lane数量增加了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------</span><br><span class="line">     ------------        ----------</span><br><span class="line">              --------------</span><br></pre></td></tr></table></figure>

<p>最终输出到<code>RoutingResponse</code>的形式也有一点讲究，先看看<code>RoutingResponse</code>的proto定义，</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">message Passage &#123;</span><br><span class="line">  repeated LaneSegment segment = 1;</span><br><span class="line">  // Note: whether the passage can lead to another passage in routing</span><br><span class="line">  optional bool can_exit = 2;</span><br><span class="line">  // Note: 当前passage如何进入下一个passage</span><br><span class="line">  optional ChangeLaneType change_lane_type = 3 [default = FORWARD];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoadSegment &#123;</span><br><span class="line">  optional string id = 1;</span><br><span class="line">  repeated Passage passage = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoutingResponse &#123;</span><br><span class="line">  optional apollo.common.Header header = 1;</span><br><span class="line">  repeated RoadSegment road = 2;</span><br><span class="line">  optional Measurement measurement = 3;</span><br><span class="line">  optional RoutingRequest routing_request = 4;</span><br><span class="line"></span><br><span class="line">  // the map version which is used to build road graph</span><br><span class="line">  optional bytes map_version = 5;</span><br><span class="line">  optional apollo.common.StatusPb status = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RoutingResponse包含一个<code>RoadSegment</code>数组，<code>RoadSegment</code>包含一个<code>Passage</code>数组，而<code>Passage</code>包含一个<code>LaneSegment</code>数组。路径中目前的passage形式是如何转化为<code>RoutingResponse</code>中的<code>RoadSegment</code>形式的呢。代码可能略显复杂，但表达的意思比较直观，就是按照橫截面变化来对passage进行分割，然后形成<code>RoadSegment</code>。[创建路由结果由<code>ResultGenerator</code>类完成，代码在<code>modules/routing/core</code>目录下。]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-----|--|</span><br><span class="line">      |--|-------|---|         |--|--------|</span><br><span class="line">                 |---|---------|--|</span><br><span class="line"></span><br><span class="line">|R1   |R2|R3     |R4 |R5       |R6|R7      |</span><br><span class="line">行驶方向&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>上面的结果共形成了7块<code>RoadSegment</code>。实际上Apollo Routing模块最终输出的结果与上图现实稍有区别，上面的结果是为了方便理解其结果输出形式。不同之处在于，passage中那些直行的Lane都单独作为<code>RoadSegment</code>输出，如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-|-|-|-|-|--|</span><br><span class="line">          |--|-|-|-|-|-|-|-|---|                 |--|-|-|-|-|-|-|-|-|</span><br><span class="line">                           |---|-|-|-|-|-|-|-|-|-|--|</span><br><span class="line"></span><br><span class="line">| | | | | |  | | | | | | | |   | | | | | | | | | |  | | | | | | | | |共32个RoadSegment</span><br><span class="line">行驶方向&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>以上就是Routing模块的输出形式。</p>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2020/02/19/apollo-routing-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/19/apollo-routing-map/" class="post-title-link" itemprop="url">Apollo Routing地图</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-19 11:56:02" itemprop="dateCreated datePublished" datetime="2020-02-19T11:56:02+08:00">2020-02-19</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Apollo自动驾驶/" itemprop="url" rel="index"><span itemprop="name">Apollo自动驾驶</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Routing地图的作用"><a href="#Routing地图的作用" class="headerlink" title="Routing地图的作用"></a>Routing地图的作用</h2><p>Routing地图是从高精度语义地图抽象出来的初步的拓扑结构，这个拓扑结构的节点(Node)是可供行驶的Lane，而边(Edge)则表示Lane之间的拓扑关系。这个拓扑关系具体指的是，举个例子，Lane B是Lane A的右邻同向车道(B是A的<code>right_neighbor_forward_lane</code>)，则会有一条Edge从A指向B，这条Edge的DirectionType是RIGHT。Routing地图是Routing模块的基本信息来源，用于进行全局的路径搜索，类似于百度地图/高德地图的导航功能。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/02/19/apollo-routing-map/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2019/09/19/samba-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/19/samba-service/" class="post-title-link" itemprop="url">Samba文件共享</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-19 11:55:23" itemprop="dateCreated datePublished" datetime="2019-09-19T11:55:23+08:00">2019-09-19</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>有时候需要在其他主机（Linux/Windows/Mac）上直接修改Linux服务器的数据，这是使用Samba搭建文件共享服务的笔记。</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/09/19/samba-service/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2019/09/17/vsftpd-on-ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/17/vsftpd-on-ubuntu/" class="post-title-link" itemprop="url">Linux环境下vsftpd的安装及配置</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-17 10:46:43" itemprop="dateCreated datePublished" datetime="2019-09-17T10:46:43+08:00">2019-09-17</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>笔记，使用<strong>VSFTPD</strong>搭建FTP服务，只允许用户使用密码登录，支持上传和下载。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>

<p>安装后<code>vsftpd -v</code>检测到版本号为<code>version 3.0.3</code>，配置文件位于<code>/etc/vsftpd.conf</code>。
试过安装后找不到<code>vsftpd.conf</code>配置文件的，<code>sudo apt-get remove --purge vsftpd</code>卸载后重新安装就有了。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/09/17/vsftpd-on-ubuntu/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2019/09/12/nginx-on-ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/nginx-on-ubuntu/" class="post-title-link" itemprop="url">Nginx服务的安装及配置</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 15:08:16" itemprop="dateCreated datePublished" datetime="2019-09-12T15:08:16+08:00">2019-09-12</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>参考官方的安装说明少走弯路 <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/" target="_blank" rel="noopener">Nginx官方安装指引</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">"deb http://nginx.org/packages/ubuntu/ <span class="variable">$(lsb_release -cs)</span> nginx"</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<p><code>nginx -v</code>查看Nginx版本号为<code>nginx/1.16.1</code>。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/09/12/nginx-on-ubuntu/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2018/12/25/raspberry-pi-self-driving-car/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/25/raspberry-pi-self-driving-car/" class="post-title-link" itemprop="url">利用树莓派搭建自动驾驶小车</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 10:52:23" itemprop="dateCreated datePublished" datetime="2018-12-25T10:52:23+08:00">2018-12-25</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/树莓派/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>一年多以前得知树莓派这样神奇的卡片式电脑的存在，于是入手了当作家用服务器来用。以前放在客厅里，室友不小心扯到电源线然后整个树莓派盒子掉水箱里了，电吹风吹一吹再自然晾干，竟然满血复活了！通过隔三叉四的知识积累，慢慢就知道了树莓派提供的丰富的GPIO口才是其精华，只当一个小主机来用实在是暴殄天物了，这个卡片式电脑配上那40个GPIO口，可以完成的作品超乎想象。后来萌生了做一个遥控车的想法，然后又想着，既然都能遥控了，为什么不让它自动驾驶呢。于是我买回来了小车底盘、4个直流减速电机（就是小时候玩的四驱车里面的那种小马达）、树莓派专用摄像头等零件，有了这些，我差不多就可以开始“闭门造车”了。</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/12/25/raspberry-pi-self-driving-car/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2018/11/27/raspberry-pi-infrared-remote-controller/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/27/raspberry-pi-infrared-remote-controller/" class="post-title-link" itemprop="url">树莓派红外遥控模块</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-27 18:58:20" itemprop="dateCreated datePublished" datetime="2018-11-27T18:58:20+08:00">2018-11-27</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/树莓派/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>从红外遥控模块的安装到投入使用费了不少时间, 在此记录一下。我使用的是<code>HX1838遥控模块</code>, 第一次买回来插线上电, 由于接反了正负极, 红外接收器马上就啪一声烧掉了, 于是又在淘宝买了<code>HX1838红外接收器</code>。得到的教训是, 对于电子元器件还是要好好找店家要电路图, 切勿凭经验、感觉。接线的时候串联一个电阻也能起到保护电路的作用。<br>红外遥控是得到Linux内核支持的, 我们需要安装必要的<code>lirc</code>库(<code>LIRC</code>全称<code>Linux Infrared Remote Control</code>), 然后通过几个文件配置红外遥控的相关参数, 可以认为, 遥控器不同按键发出的信号在接收端就表现为不一样的电信号序列, 我们需要设置这些信号序列对应了遥控器上的哪个键, 除此之外, 我们还可以自定义这些按键的行为。关于<code>LIRC</code>, 官网有很详细的Manual <a href="http://www.lirc.org/html/index.html" target="_blank" rel="noopener">Welcome to the LIRC Manual</a></p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/27/raspberry-pi-infrared-remote-controller/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2018/11/27/raspberry-pi-pwm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/27/raspberry-pi-pwm/" class="post-title-link" itemprop="url">树莓派脉冲宽度调制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-27 16:11:26" itemprop="dateCreated datePublished" datetime="2018-11-27T16:11:26+08:00">2018-11-27</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/树莓派/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>在给树莓派小车做加速和减速功能时遇到了脉冲宽度调制的问题，到底什么是脉冲宽度调制，跟智能小车直流电机的转速有什么关系？这几个问题没搞明白的话，感觉小车的控制程序很难继续往下写，于是搜集整理了一下资料。大概这也是不少非电子工程专业的同学在折腾树莓派GPIO时会遇到的问题。</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/27/raspberry-pi-pwm/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2018/10/16/leveldb-installation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/16/leveldb-installation/" class="post-title-link" itemprop="url">LevelDB编译、安装与使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-16 11:35:57" itemprop="dateCreated datePublished" datetime="2018-10-16T11:35:57+08:00">2018-10-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>由于<code>LevelDB</code>现在用<code>CMake</code>编译, 网上看到的教程大都是直接<code>make</code>搞定的, 现在不管用了。从编译、安装到使用, 踩了一些坑, 在此记录下来。 </p>
</blockquote>
<h3 id="CMake版本太低导致编译失败"><a href="#CMake版本太低导致编译失败" class="headerlink" title="CMake版本太低导致编译失败"></a>CMake版本太低导致编译失败</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/google/leveldb.git</span><br><span class="line">$ mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br><span class="line">CMake Error at CMakeLists.txt:5 (cmake_minimum_required):</span><br><span class="line">  CMake 3.9 or higher is required.  You are running version 3.5.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/16/leveldb-installation/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cheung.site/2018/09/23/vim-as-an-ide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龚华昌">
      <meta itemprop="description" content="<h6>每一个认真的技术人<br/>心底都有一个技术英雄梦</h6>">
      <meta itemprop="image" content="/images/sanji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工程师学徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/09/23/vim-as-an-ide/" class="post-title-link" itemprop="url">Vim与YouCompleteMe代码补全</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-23 17:08:05" itemprop="dateCreated datePublished" datetime="2018-09-23T17:08:05+08:00">2018-09-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>默认的Vim配置给人的感觉实在无法称得上是编辑器之神, 在使用简单的Vim配置好久之后, 终于有时间好好折腾一下Vim插件, 一番挣扎之后, 终于顺利为Vim加上代码自动补全的功能。</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/09/23/vim-as-an-ide/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/sanji.jpg" alt="龚华昌">
            
              <p class="site-author-name" itemprop="name">龚华昌</p>
              <div class="site-description motion-element" itemprop="description"><h6>每一个认真的技术人<br>心底都有一个技术英雄梦</h6></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">47</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/wahcheung" title="GitHub &rarr; https://github.com/wahcheung" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:huachang.gong@outlook.com" title="E-Mail &rarr; mailto:huachang.gong@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://leetcode.com/wahcheung" title="LeetCode &rarr; https://leetcode.com/wahcheung" rel="noopener" target="_blank"><i class="fa fa-fw fa-trophy"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龚华昌</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

<!-- 页面点击烟花特效 -->

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
  <script type="text/javascript" src="/js/anime.min.js"></script>
  <script type="text/javascript" src="/js/fireworks.js"></script>

